# Malloc Lab Writeup

**分离适配**的基本思想就是将所有空闲块分成大小类，分别分成0~8,9~16,17~32,33~64,65~128…… 2049~4096,4097~正无穷，这么几个大小类的空闲链表，然后我们想要进行malloc的时候，就将空闲块进行筛选，将其分到对应的大小块中进行搜索，这样就可以将malloc搜索块的时间从所有空的空闲块降低到局部链表的空闲块中，提高了效率。并且事实证明，当分到对应的大小类链表的时候，它的空间也会在大小类链表的范围里面，这样使得即使是首次适配也可以是空间利用率接近最佳适配。那么，他的free也是相同，在合并的时候，将前后空闲块从链表中删除，然后合并，合并后再加入对应的空闲链表，分割的时候，也是分割后将分割块插入适当的空闲链表中。



- `mm_init`: 初始化链表、抬高4字节使chunk的用户空间通过8字节对齐标准、手动分配并设置第一块chunk的`PREV_INUSE`位为0、分配一块超大内存给`top_chunk`。

- `mm_malloc`: 首先查找各个链表中是否存在所需要的chunk。

  - 如果有，则断开链表、切割chunk、设置chunk的头部与尾部（只有切割下的chunk会设置尾部）、将剩余chunk放回链表、返回用户地址一条龙。

  - 如果没有，则判断top chunk的空间是否足够分配

    - 如果足够，切割top chunk、设置chunk的首尾、重新设置top_chunk、将目标chunk的用户地址返回。
    - 如果不够，将当前top chunk插入链表中，重新分配一块超大内存给`top_chunk`指针，之后重新递归执行`mm_malloc`，返回该递归执行的返回值。
  
- `mm_free`: chunk的释放策略非常简单，直接将传入的chunk插入特定索引的链表中即可。插入时自动合并相邻的chunk。

- `mm_realloc`: 该函数先将传入指针的上下两块可能空闲的chunk合并，然后判断当前chunk的大小是否符合需求。
  
  - 如果不符合要求，则分配一块新的内存，复制数据，并最后释放旧的chunk
- 如果合并后的chunk大小满足需求，则复制数据并切割多余的空间。



总之感觉就是简化了很多的glibc malloc，少了很多检查，原子操作等。